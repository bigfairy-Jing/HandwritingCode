## 自动生成readme.md文件  
* npm run create
## 说明
* [info.md](./info.md) 



### [1.apply&call](./1.apply&call.js)



### [2.bind](./2.bind.js)



### [3.instanceof](./3.instanceof.js)
* instanceof 判断左边的原型是否存在于右边的原型链中  
* 获取对象原型


### [4.new](./4.new.js)
* new 实际做了三件事情  
* 1. 让实例的对象可以访问私有属性  
* 2. 让实例对象可以访问构造函数原型(constructor.prototype)所在的原型链的属性  
* 3. 考虑构造函数有返回值的情况


### [5.Object.create](./5.Object.create.js)
* 方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。


### [6.柯里化](./6.柯里化.js)
* 利用函数的length属性(形参) 与 arguments的length比较


### [7.寄生组合继承](./7.寄生组合继承.js)
* 继承父类的属性  
* 继承父类的静态方法  
* constructor 重新指向child


### [8.TypeScript中Class私有属性private原理](./8.TypeScript中Class私有属性private原理.js)
* 私有属性满足  
* 1. 能被class内部不同方法访问,但不能在类外部被访问  
* 2. 子类不能继承父类的私有属性


### [9.数组排序](./9.数组排序.js)
* 1. 冒泡排序  
* 2. 选择排序: 遍历自身以后的元素，最小的元素跟自己调换位置  
* 3. 插入排序将元素插入到已经排序好的数组中  
* arr[0]默认为已经排序的数组  
* 4. 快速排序 选择基准值 mid，循环原数组，  
* 小于基准值放左边数组，大于放右边数组，然后 concat 组合，最后依靠递归完成排序。


### [10.数组去重](./10.数组去重.js)
* 1.双层循环  
* 2.indexOf  
* 3. 排序后去重, 如果是第一个元素或者相邻元素不相同  
* 4.Set or Mat


### [11.map](./11.map.js)
* 保证len为数字


### [12.reduce](./12.reduce.js)



### [13.filter](./13.filter.js)



### [14.随机字符串](./14.随机字符串.js)



### [15.斐波那契数列](./15.斐波那契数列.js)
* 递归， 时间复杂度O(2^n)  
* 迭代， 时间复杂度为O(n)


### [16.浅拷贝](./16.浅拷贝.js)
* 浅拷贝：   
* 1. 只能拷贝一层对象，如果对象有嵌套那么浅拷贝无能为力   
* 2. 若拷贝属性是引用类型，拷贝就是内存地址，修改内容会相互影响


### [17.深拷贝](./17.深拷贝.js)
* 1. 乞丐版 ： 无法解决循环引用 2. 无法拷贝特殊的对象，比如 函数，RegExp,Date,Set，Map  
* 2. 几乎覆盖所有版本  
* 基本数据  
* 解决循环引用  
*解决函数  
* 数组 普通对象 Set Map处理  
* 测试


### [18.解析URL](./18.解析URL.js)
* URL  
* scheme: * user:password@ host: port path ? query # fragment  
* 举例子 https:*fairy:shen@www.aiheshui.com:80/file?test1=3&test2=4#load-0  
*fairy:shen@www.aiheshui.com:80/file?test1=3&test2=4#load-0'  
*(?:([^:]*)(?::?(.*))@)?'  
* 协议  
* 用户名  
* 密码  
* 主机  
* 端口  
* 路径  
* 查询字符串 queryString  
* 锚点  
* 协议  
* 用户名  
* 密码  
* 主机  
* 端口  
* 路径  
* 查询字符串 queryString  
* 锚点  
* 单独解析查询字符串  
* 对于形如 `list[]` 的解析成数组  
* 对于形如 obj{} 的解析为对象  
* 测试  
* 简易版本queryParse  
* 不合理的点  
* 相同字段如何处理  
* 没有替换 + 为 %20  
* 只有 key / 只有 value  
* 推荐使用js-url query-string  node中存在url.parse querystring.parse


### [19.JSONP](./19.JSONP.js)



### [20.防抖&节流](./20.防抖&节流.js)
* 1. 防抖 避免不必要连续操作的误操作  
* 2. 节流: 固定频率促发，scroll事件等  
* 适合逻辑较为复杂情况防抖  
* 固定频率促发


### [21.图片懒加载](./21.图片懒加载.js)
* 实现方式有三种  
* 1. clentHeight scrollTop offsetTop  
* 2. getBoudingClientRect  
* 3. intersectionObserver  
* 这里只写getBoudingClientRect 和 IntersectionObserver 方法  
* @1 getBoundingClientRect  
* @2 IntersectionObserver


### [22.Promise系列](./22.Promise系列.js)
* 链式调用  
* 错误捕获 (冒泡)  
* 成功回调函数队列  
* 失败回调函数队列  
* 成功函数依次执行  
* 失败的函数依次执行  
* 立即执行executor  
* 把内部的resolve 和 reject传入executor, 用户可以调用resolve和reject  
* 保存this  
* 分两种情况  
* 1. 回调函数返回值是Promise,执行then操作  
* 2. 不是Promise, 调用新的Promise的resolve函数  
* 不同点 此时reject  
* 附加


### [23.配器器模式](./23.配器器模式.js)
* 适配器模式 的作用就是解决两个软件实体间接口不兼容情况，实体电器例如电源适配器、USB 转接口、各种转换器等。  
* 需求1 对接多个平台外卖  
* 提供给使用者调用  
* 这个时候百度外卖也想集成SDK,但是百度外卖的方法是generate  
* 适配器  
* 2. 需求2 数据格式变更 当有一天后端数据格式发生变化了。前端因为已经深入了页面。  
* 这个时候我们可以写一个适配器用来将新的数据格式转换为旧的数据格式


### [24.观察者模式&发布订阅模式](./24.观察者模式&发布订阅模式.js)
* 发布订阅模式和观察者模式区别  
* 观察者模式中，观察者知道被观察者的，被观察者一直保持对被观察者进行记录。 松散耦合的  
* 发布订阅模式中，发布者不知道对方的存在，它们只是通过消息代理进行通信，同时是异步的，比如消息队列。在发布订阅模式中，是属于解耦合的  
* 观察者模式例子：家报社（Subject）一发布报纸，就会立马派送给所有订报（Obsever）的人，订报的人就能获取报纸内容。 这里订报纸的人知道报社，报社也知道订报纸的人  
* 观察者队列  
* 亲自通知观察者  
* 创建观察者1  
* 创建观察者2  
* 创建目标对象  
* 发布订阅模式  
*监听订阅  
* 删除某个事件的回调  
* 如果所有的都删了那么变成非数组  
* 


### [25.策略模式](./25.策略模式.js)
* 策略模式： 简单理解就是定义一系列同级算法（功能的具体实现），在一个稳定的环境下使用


### [27.代理模式](./27.代理模式.js)
* 代理模式： 为某个对象提供一种代理以控制对这个对象的访问  
* 举个例子：双十一，小美有亿件快递到了，有些包裹太重了自己拿不动。  
* 于是，她拜托工具人舔狗小明帮忙，小明欣然前往快递点取件。  
* 这里，小明帮小美取快递就起到了代理的作用。  
* 注意：整个动作还是小美发起的，小明可以理解为一个透明的中间人，直接看代码。


### [28.单例模式](./28.单例模式.js)
* 单例模式：它保证一个类仅有一个实例，并提供一个访问它的全局访问点。  
* 比如数据库：我们在访问网站，请求数据时，不管建立多少连接对数据读写，  
* 都是指向同一个数据库（这里不考虑数据库的集群、备份、缓存镜像等...）。  
* 1. 饿汉式单例  
* 2.懒汉式单例模式 , 正常情况下建议使用懒汉式单例


### [29.工厂模式](./29.工厂模式.js)
* 工厂模式细分为: 简单的工厂模式  工厂方法模式  抽象工厂模式  
* 1. 简单工厂模式  
* 静态方法，可以在外部直接调用，不用实例化  
* 在静态方法中返回实例  
* 2. 工厂方法模式  
* 注意这里  
* 工厂方法只做一件事，就是实例化对象  
* 3. 抽象工厂模式  
* 开放封闭原则： 对扩展开放，对修改封闭。  
* 抽象类  
* 产品类簇


### [30.装饰器模式](./30.装饰器模式.js)
* 装饰器模式 定义：在不改变对象自身的基础上，  
* 在程序运行期间给对象动态地添加方法。  
* 简而言之就是对对象进行包装，返回一个新的对象描述（descriptor）。  
* 这个概念其实和 React 中的高阶组件、ES6 装饰器、TypeScript   
* 装饰器-依赖注入 @Injectable 等类似。  
* Decorator  
* target 被装饰器的类的原型  
* name 被装饰的类，属性， 方法 的名字  
* descriptor 被装饰的类， 属性， 方法的descriptor


### [31.AJAX](./31.AJAX.js)



### [32.Vue](./32.Vue.js)
* 见个人手写代码Evue


### [33.将虚拟dom转换为真实Dom](./33.将虚拟dom转换为真实Dom.js)
* 如果是数字类型，转为字符串  
* 字符串类型直接生成文本节点  
* 普通dom


### [34.Vue-Router](./34.Vue-Router.js)
* Vue 构造函数  
* options 路由映射表，  
* new 1 个Vue实例储存当前路由属性current  
* 初始化监听路由变化  
* 简单数据转换 this.routeMap = { '/': Home, '/page1': '/page1'}  
* 组件注册


### [35.REDUX](./35.REDUX.js)
* 先处理 enhancer  
* 如果enhancer存在并且是函数，我们将createStore 作为参数传给他  
* 返回一个新的createStore  
* 再拿这个新的createStoer执行，应该得到一个Store, 返回Store